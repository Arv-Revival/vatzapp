{"version":3,"sources":["../node_modules/@progress/kendo-data-query/dist/es/utils.js","../node_modules/@progress/kendo-data-query/dist/es/filtering/filter-descriptor.interface.js","../node_modules/@progress/kendo-data-query/dist/es/funcs.js","../node_modules/@progress/kendo-data-query/dist/es/filter-serialization.common.js","../node_modules/@progress/kendo-data-query/dist/es/filtering/filter.operators.js","../node_modules/@progress/kendo-data-query/dist/es/accessor.js","../node_modules/@progress/kendo-data-query/dist/es/odata.operators.js","../node_modules/@progress/kendo-data-query/dist/es/mvc/operators.js","../node_modules/@progress/kendo-data-query/dist/es/mvc/deserialization.js","../node_modules/@progress/kendo-data-query/dist/es/sorting/sort-array.operator.js","../node_modules/@progress/kendo-data-query/dist/es/transducers.js","../node_modules/@progress/kendo-data-query/dist/es/grouping/aggregate.operators.js","../node_modules/@progress/kendo-data-query/dist/es/filtering/filter-no-eval.js","../node_modules/@progress/kendo-data-query/dist/es/filtering/filter-expression.factory.js","../node_modules/@progress/kendo-data-query/dist/es/grouping/group.operators.js","../node_modules/@progress/kendo-data-query/dist/es/sorting/sort.js","../node_modules/@progress/kendo-data-query/dist/es/array.operators.js","../node_modules/@babel/runtime/helpers/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/defineProperty.js","../node_modules/@babel/runtime/helpers/inheritsLoose.js","../node_modules/@babel/runtime/helpers/setPrototypeOf.js"],"names":["isPresent","value","undefined","isBlank","isArray","Array","isFunction","isString","isNotNullOrEmptyString","trim","length","isNullOrEmptyString","isNumeric","isNaN","parseFloat","isDate","getTime","isCompositeFilterDescriptor","source","filters","x","ifElse","predicate","right","left","compose","args","_i","arguments","data","reduceRight","acc","curr","toUTC","date","Date","UTC","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","isDateValue","normalizeOperator","descriptor","map","filter","key","result","Object","assign","operator","equal","equals","equalto","ge","greater","greaterthan","greaterthanequal","isempty","isequalto","isgreaterthan","isgreaterthanorequalto","islessthan","islessthanorequalto","isnotempty","isnotequalto","isnull","le","less","lessthan","lessthanequal","ne","notequal","notequals","notequalto","notsubstringof","toLowerCase","normalizeFilters","logic","normalizeDescriptor","getterCache","FIELD_REGEX","obj","what","getter","field","safe","fields","replace","_","index","indexAccessor","push","idx","pairwise","empty","has","accessor","isNotEmpty","isNotEmptyArray","runOrEmpty","fn","formatDescriptors","formatter","state","join","sanitizeDateLiterals","apply","_a","s","RegExp","removeAfterDot","str","slice","indexOf","directionFormatter","_b","dir","take","aggregates","skip","group","sort","formatSort","formatGroup","formatAggregates","aggregate","formatDateValue","JSON","stringify","transformSkip","Math","floor","transformTake","transformGroup","transformSort","transformAggregates","filterFormatter","set","ignoreCase","target","prop","fieldName","g1","convert","mapper","values","keys","reduce","bind","translateAggregate","translateAggregates","valueOrDefault","defaultValue","translateGroup","hasSubgroups","items","Aggregates","Member","member","HasSubgroups","Items","Key","compare","a","b","localeCompare","compareDesc","descriptorAsFunc","initial","groupCombinator","position","agg","groupValue","valueToString","__position","aggregatesCombinator","descriptors","functions","fieldAccessor","aggregateName","aggregateAccessor","fieldAggregates","aggregateFunction","average","count","calc","max","Number","NEGATIVE_INFINITY","min","POSITIVE_INFINITY","sum","concat","arr","transform","isTransformerResult","__value","reduced","exec","initialValue","length_1","identity","aggregateBy","transformers","forEach","expandAggregates","operatorsMap","contains","doesnotcontain","doesnotendwith","doesnotstartwith","lastIndexOf","endswith","eq","gt","gte","isnotnull","lt","lte","neq","startswith","dateRegExp","transformFilter","itemProp","typedGetter","convertValue","op","transformCompositeFilter","combiner","compileFilter","normalizeGroups","groupBy","originalData","view","aggregateResult","filteredData","filterBy","start","end","mid","middle","leftLength","rightLength","temp","cursor1","cursor2","dest","merge","orderBy","some","comparer","composeSortDescriptors","process","skipCount","takeCount","filterDescriptor","sortDescriptors","total","hasFilters","hasGroups","counter","limit","module","exports","self","ReferenceError","__esModule","defineProperty","enumerable","configurable","writable","setPrototypeOf","subClass","superClass","prototype","create","constructor","_setPrototypeOf","o","p","__proto__"],"mappings":"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","file":"static/js/2.50f729f4.chunk.js","sourcesContent":["/**\n * @hidden\n */\nexport var isPresent = function (value) { return value !== null && value !== undefined; };\n/**\n * @hidden\n */\nexport var isBlank = function (value) { return value === null || value === undefined; };\n/**\n * @hidden\n */\nexport var isArray = function (value) { return Array.isArray(value); };\n/**\n * @hidden\n */\nexport var isFunction = function (value) { return typeof value === 'function'; };\n/**\n * @hidden\n */\nexport var isString = function (value) { return typeof value === 'string'; };\n/**\n * @hidden\n */\nexport var isTruthy = function (value) { return !!value; };\n/**\n * @hidden\n */\nexport var isNullOrEmptyString = function (value) { return isBlank(value) || value.trim().length === 0; };\n/**\n * @hidden\n */\nexport var isNotNullOrEmptyString = function (value) { return !isNullOrEmptyString(value); };\n/**\n * @hidden\n */\nexport var isNumeric = function (value) { return !isNaN(value - parseFloat(value)); };\n/**\n * @hidden\n */\nexport var isDate = function (value) { return value && value.getTime; };\n","import { isPresent } from '../utils';\n// tslint:enable:max-line-length\n/**\n * @hidden\n * Type guard for `CompositeFilterDescriptor`.\n */\nexport var isCompositeFilterDescriptor = function (source) {\n    return isPresent(source.filters);\n};\n","/**\n * @hidden\n */\nexport var ifElse = function (predicate, right, left) { return function (value) { return predicate(value) ? right(value) : left(value); }; };\n/**\n * @hidden\n * Performs the right-to-left function composition. Functions should have a unary.\n */\nexport var compose = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return function (data) { return args.reduceRight(function (acc, curr) { return curr(acc); }, data); };\n};\n/**\n * @hidden\n */\nexport var constant = function (x) { return function () { return x; }; };\n/**\n * @hidden\n */\nexport var identity = function (x) { return x; };\n","import * as tslib_1 from \"tslib\";\nimport { isString, isDate } from './utils';\n/**\n * @hidden\n * Creates a single arity function which wraps the value based on the provided predicate.\n * @example\n * ```\n * wrapIf(() => ignoreCase) `tolower(${field})`\n * //ignoreCase=true -> tolower(${field})`\n * //ignoreCase=false -> ${field}`\n * ```\n */\nexport var wrapIf = function (predicate) { return function (str) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    return predicate() ? \"\" + str[0] + args[0] + str[1] : args[0];\n}; };\n/**\n * @hidden\n */\nexport var toUTC = function (date) {\n    return new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));\n};\n/**\n * @hidden\n */\nexport var quote = function (_a) {\n    var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n    return ({\n        value: \"'\" + value.replace(/'/g, \"''\") + \"'\",\n        field: field,\n        ignoreCase: ignoreCase,\n        operator: operator\n    });\n};\n/**\n * @hidden\n */\nexport var encodeValue = function (_a) {\n    var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n    return ({\n        value: \"\" + encodeURIComponent(value),\n        field: field,\n        ignoreCase: ignoreCase,\n        operator: operator\n    });\n};\n/**\n * @hidden\n */\nexport var toLower = function (_a) {\n    var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n    return ({\n        field: wrapIf(function () { return ignoreCase; })(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"tolower(\", \")\"], [\"tolower(\", \")\"])), field),\n        value: value,\n        ignoreCase: ignoreCase,\n        operator: operator\n    });\n};\n/**\n * @hidden\n */\nexport var normalizeField = function (_a) {\n    var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n    return ({\n        value: value,\n        field: field.replace(/\\./g, \"/\"),\n        ignoreCase: ignoreCase,\n        operator: operator\n    });\n};\n/**\n * @hidden\n */\nexport var isStringValue = function (x) { return isString(x.value); };\n/**\n * @hidden\n */\nexport var isDateValue = function (x) { return isDate(x.value); };\n/**\n * @hidden\n */\nexport var serializeFilters = function (map, join) { return function (filter) {\n    var brackets = wrapIf(function () { return filter.filters.length > 1; });\n    return brackets(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"(\", \")\"], [\"(\",\n        \")\"])), filter.filters\n        .map(map)\n        .join(join(filter)));\n}; };\nvar templateObject_1, templateObject_2;\n","import { isPresent, isString, isArray } from '../utils';\nimport { isCompositeFilterDescriptor } from './filter-descriptor.interface';\nvar operatorMap = function (key) { return ({\n    \"!=\": \"neq\",\n    \"<\": \"lt\",\n    \"<=\": \"lte\",\n    \"==\": \"eq\",\n    \">\": \"gt\",\n    \">=\": \"gte\",\n    equal: \"eq\",\n    equals: \"eq\",\n    equalto: \"eq\",\n    ge: \"gte\",\n    greater: \"gt\",\n    greaterthan: \"gt\",\n    greaterthanequal: \"gte\",\n    isempty: \"isempty\",\n    isequalto: \"eq\",\n    isgreaterthan: \"gt\",\n    isgreaterthanorequalto: \"gte\",\n    islessthan: \"lt\",\n    islessthanorequalto: \"lte\",\n    isnotempty: \"isnotempty\",\n    isnotequalto: \"neq\",\n    isnull: \"isnull\",\n    le: \"lte\",\n    less: \"lt\",\n    lessthan: \"lt\",\n    lessthanequal: \"lte\",\n    ne: \"neq\",\n    notequal: \"neq\",\n    notequals: \"neq\",\n    notequalto: \"neq\",\n    notsubstringof: \"doesnotcontain\"\n}[key.toLowerCase()] || key); };\nvar normalizeOperator = function (descriptor) {\n    if (descriptor.filters) {\n        descriptor.filters = descriptor.filters.map(function (filter) {\n            var result = Object.assign({}, filter);\n            if (!isCompositeFilterDescriptor(filter) && isString(filter.operator)) {\n                result.operator = operatorMap(filter.operator);\n            }\n            if (isCompositeFilterDescriptor(filter)) {\n                normalizeOperator(result);\n            }\n            return result;\n        });\n    }\n};\nvar normalizeDescriptor = function (descriptor) {\n    if (!isCompositeFilterDescriptor(descriptor)) {\n        return {\n            filters: isArray(descriptor) ? descriptor : [descriptor],\n            logic: \"and\"\n        };\n    }\n    return Object.assign({}, descriptor);\n};\n// tslint:disable:max-line-length\n/**\n * Converts a [FilterDescriptor]({% slug api_kendo-data-query_filterdescriptor %}) into a [CompositeFilterDescriptor]({% slug api_kendo-data-query_compositefilterdescriptor %}). If a `CompositeFilterDescriptor` is passed, no modifications will be made.\n *\n * @param {CompositeFilterDescriptor | FilterDescriptor} descriptor - The descriptor that will be normalized.\n * @returns {CompositeFilterDescriptor} - The normalized descriptor.\n */\n// tslint:enable:max-line-length\nexport var normalizeFilters = function (descriptor) {\n    if (isPresent(descriptor)) {\n        descriptor = normalizeDescriptor(descriptor);\n        normalizeOperator(descriptor);\n    }\n    return descriptor;\n};\n","import { isPresent } from './utils';\nvar getterCache = {};\nvar FIELD_REGEX = /\\[(?:(\\d+)|['\"](.*?)['\"])\\]|((?:(?!\\[.*?\\]|\\.).)+)/g;\n// tslint:disable-next-line:no-string-literal\ngetterCache['undefined'] = function (obj) { return obj; };\n/**\n * @hidden\n */\nexport var getter = function (field, safe) {\n    var key = field + safe;\n    if (getterCache[key]) {\n        return getterCache[key];\n    }\n    var fields = [];\n    field.replace(FIELD_REGEX, function (_, index, indexAccessor, field) {\n        fields.push(isPresent(index) ? index : (indexAccessor || field));\n        return undefined;\n    });\n    getterCache[key] = function (obj) {\n        var result = obj;\n        for (var idx = 0; idx < fields.length; idx++) {\n            result = result[fields[idx]];\n            if (!isPresent(result) && safe) {\n                return result;\n            }\n        }\n        return result;\n    };\n    return getterCache[key];\n};\n","import * as tslib_1 from \"tslib\";\nimport { isPresent, isNotNullOrEmptyString } from './utils';\nimport { serializeFilter } from './odata-filtering.operators';\nimport { ifElse, constant } from './funcs';\nvar serializeSort = function (orderby) {\n    var str = orderby\n        .filter(function (sort) { return isPresent(sort.dir); })\n        .map(function (sort) {\n        var order = sort.field.replace(/\\./g, \"/\");\n        return sort.dir === \"desc\" ? order + \" desc\" : order;\n    }).join(\",\");\n    return str ? \"$orderby=\" + str : str;\n};\nvar emptyString = constant('');\nvar concat = function (a) { return function (b) { return a + b; }; };\nvar serializeKey = function (strings, val) { return ifElse(isPresent, concat(strings[0]), emptyString)(val); };\nvar rules = function (settings, state) { return function (key) { return ({\n    \"filter\": serializeFilter(state.filter || {}, settings),\n    \"skip\": serializeKey(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject([\"$skip=\", \"\"], [\"$skip=\", \"\"])), state.skip),\n    \"sort\": serializeSort(state.sort || []),\n    \"take\": serializeKey(templateObject_2 || (templateObject_2 = tslib_1.__makeTemplateObject([\"$top=\", \"\"], [\"$top=\", \"\"])), state.take)\n}[key]); }; };\n// tslint:enable:max-line-length\n/**\n * Converts a [State]({% slug api_kendo-data-query_state %}) into an OData v4 compatible string.\n *\n * @param {State} state - The state that will be serialized.\n * @param {ODataSettings} settings - The settings that are used during the serialization.\n * @returns {string} - The serialized state.\n */\nexport var toODataString = function (state, settings) {\n    if (settings === void 0) { settings = {}; }\n    return (Object.keys(state)\n        .map(rules(settings, state))\n        .filter(isNotNullOrEmptyString)\n        .join('&'));\n};\nvar templateObject_1, templateObject_2;\n","import * as tslib_1 from \"tslib\";\nimport { isCompositeFilterDescriptor } from '../filtering/filter-descriptor.interface';\nimport { isPresent, isNotNullOrEmptyString, isArray } from '../utils';\nimport { getter } from '../accessor';\nimport { compose, ifElse, identity } from '../funcs';\nimport { isStringValue, isDateValue, quote, serializeFilters, toUTC, encodeValue } from '../filter-serialization.common';\nvar toQueryString = function (values) { return values.reduce(function (acc, _a) {\n    var key = _a[0], value = _a[1];\n    return acc.concat([key + \"=\" + value]);\n}, []); };\nvar toObject = function (values) { return values.reduce(function (acc, _a) {\n    var key = _a[0], value = _a[1];\n    var _b;\n    return (tslib_1.__assign({}, acc, (_b = {}, _b[key] = value, _b)));\n}, {}); };\nvar pairwise = function (key) { return function (value) { return [key, value]; }; };\nvar empty = function () { return null; };\nvar isNotEmptyArray = function (value) { return isPresent(value) && isArray(value) && value.length > 0; };\nvar has = function (accessor) { return function (value) { return isPresent(accessor(value)); }; };\nvar isNotEmpty = function (accessor) { return function (value) { return isNotEmptyArray(accessor(value)); }; };\nvar runOrEmpty = function (predicate, fn) { return ifElse(predicate, fn, empty); };\nvar calcPage = function (_a) {\n    var skip = _a.skip, take = _a.take;\n    return Math.floor((skip || 0) / take) + 1;\n};\nvar formatDescriptors = function (accessor, formatter) { return function (state) { return (accessor(state).map(formatter).join(\"~\")); }; };\nvar removeAfter = function (what) { return function (str) { return str.slice(0, str.indexOf(what)); }; };\nvar replace = function (patterns) {\n    return compose.apply(void 0, patterns.map(function (_a) {\n        var left = _a[0], right = _a[1];\n        return function (s) { return s.replace(new RegExp(left, \"g\"), right); };\n    }));\n};\nvar sanitizeDateLiterals = replace([[\"\\\"\", \"\"], [\":\", \"-\"]]);\nvar removeAfterDot = removeAfter(\".\");\nvar directionFormatter = function (_a) {\n    var field = _a.field, _b = _a.dir, dir = _b === void 0 ? \"asc\" : _b;\n    return field + \"-\" + dir;\n};\nvar aggregateFormatter = function (_a) {\n    var field = _a.field, aggregate = _a.aggregate;\n    return field + \"-\" + aggregate;\n};\nvar take = getter(\"take\");\nvar aggregates = getter(\"aggregates\");\nvar skip = getter(\"skip\");\nvar group = getter(\"group\");\nvar sort = getter(\"sort\", true);\nvar formatSort = formatDescriptors(sort, directionFormatter);\nvar formatGroup = formatDescriptors(group, directionFormatter);\nvar formatAggregates = formatDescriptors(aggregates, aggregateFormatter);\nvar prefixDateValue = function (value) { return \"datetime'\" + value + \"'\"; };\nvar formatDateValue = compose(prefixDateValue, removeAfterDot, sanitizeDateLiterals, JSON.stringify, toUTC);\nvar formatDate = function (_a) {\n    var field = _a.field, value = _a.value, ignoreCase = _a.ignoreCase, operator = _a.operator;\n    return ({\n        value: formatDateValue(value),\n        field: field,\n        ignoreCase: ignoreCase,\n        operator: operator\n    });\n};\nvar normalizeSort = function (state) { return Object.assign({}, state, {\n    sort: (sort(state) || []).filter(function (_a) {\n        var dir = _a.dir;\n        return isNotNullOrEmptyString(dir);\n    })\n}); };\nvar transformSkip = compose(pairwise('page'), calcPage);\nvar transformTake = compose(pairwise('pageSize'), take);\nvar transformGroup = compose(pairwise('group'), formatGroup);\nvar transformSort = compose(pairwise('sort'), formatSort);\nvar transformAggregates = compose(pairwise('aggregate'), formatAggregates);\nvar serializePage = runOrEmpty(has(skip), transformSkip);\nvar serializePageSize = runOrEmpty(has(take), transformTake);\nvar serializeGroup = runOrEmpty(isNotEmpty(group), transformGroup);\nvar serializeAggregates = runOrEmpty(has(aggregates), transformAggregates);\nvar serializeSort = compose(runOrEmpty(isNotEmpty(sort), transformSort), normalizeSort);\nvar hasField = function (_a) {\n    var field = _a.field;\n    return isNotNullOrEmptyString(field);\n};\nvar filterFormatter = function (_a) {\n    var field = _a.field, operator = _a.operator, value = _a.value;\n    return field + \"~\" + operator + \"~\" + value;\n};\nvar dateFormatter = ifElse(isDateValue, compose(filterFormatter, formatDate), filterFormatter);\nvar typedFormatter = function (encode) { return runOrEmpty(hasField, ifElse(isStringValue, compose(filterFormatter, quote, encode ? encodeValue : identity), dateFormatter)); };\nvar join = function (_a) {\n    var logic = _a.logic;\n    return \"~\" + logic + \"~\";\n};\nvar serialize = function (encode) { return serializeFilters(function (filter) { return ifElse(isCompositeFilterDescriptor, serialize(encode), typedFormatter(encode))(filter); }, join); };\nvar serializeFilter = function (_a, encode) {\n    var filter = _a.filter;\n    if (filter && filter.filters) {\n        var filters = serialize(encode)(filter);\n        if (filters.length) {\n            return ['filter', filters];\n        }\n    }\n    return null;\n};\nvar rules = function (state, encode) {\n    if (encode === void 0) { encode = true; }\n    return function (key) { return ({\n        \"aggregates\": serializeAggregates(state),\n        \"filter\": serializeFilter(state, encode),\n        \"group\": serializeGroup(state),\n        \"skip\": serializePage(state),\n        \"sort\": serializeSort(state),\n        \"take\": serializePageSize(state)\n    }[key]); };\n};\n/**\n * Converts a [DataSourceRequestState]({% slug api_kendo-data-query_datasourcerequeststate %}) into a string\n * that is comparable with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {string} - The serialized state.\n *\n * @example\n * {% platform_content angular %}\n * ```ts\n *  import {\n *      toDataSourceRequestString,\n *      translateDataSourceResultGroups,\n *      translateAggregateResults\n * } from '@progress/kendo-data-query';\n *\n * export class Service {\n *  private BASE_URL: string = '...';\n *\n *  constructor(private http: Http) { }\n *\n *  // Omitted for brevity...\n *\n *  private fetch(state: DataSourceRequestState): Observable<DataResult> {\n *   const queryStr = `${toDataSourceRequestString(state)}`; //serialize the state\n *   const hasGroups = state.group && state.group.length;\n *\n *   return this.http\n *       .get(`${this.BASE_URL}?${queryStr}`) //send the state to the server\n *       .map(response => response.json())\n *       .map(({Data, Total, AggregateResults}) => // process the response\n *           (<GridDataResult>{\n *               //if there are groups convert them to compatible format\n *               data: hasGroups ? translateDataSourceResultGroups(Data) : Data,\n *               total: Total,\n *               // convert the aggregates if such exists\n *               aggregateResult: translateAggregateResults(AggregateResults)\n *           })\n *       );\n *  }\n * }\n * ```\n * {% endplatform_content %}\n *\n * {% platform_content react %}\n * ```jsx\n * import React from 'react';\n * import { toDataSourceRequestString, translateDataSourceResultGroups } from '@progress/kendo-data-query';\n *\n * export function withState(WrappedGrid) {\n *     return class StatefullGrid extends React.Component {\n *         constructor(props) {\n *             super(props);\n *             this.state = { dataState: { skip: 0, take: 20 } };\n *         }\n *\n *         render() {\n *             return (\n *                 <WrappedGrid\n *                     filterable={true}\n *                     sortable={true}\n *                     pageable={{ pageSizes: true }}\n *                     {...this.props}\n *                     total={this.state.total}\n *                     data={this.state.data}\n *                     skip={this.state.dataState.skip}\n *                     pageSize={this.state.dataState.take}\n *                     filter={this.state.dataState.filter}\n *                     sort={this.state.dataState.sort}\n *                     dataStateChange={this.dataStateChange}\n *                 />\n *             );\n *         }\n *\n *         componentDidMount() {\n *             this.fetchData(this.state.dataState);\n *         }\n *\n *         dataStateChange = (changeEvent) => {\n *             this.setState({ dataState: changeEvent.data });\n *             this.fetchData(changeEvent.data);\n *         }\n *\n *         fetchData(dataState) {\n *             const queryStr = `${toDataSourceRequestString(dataState)}`; // Serialize the state\n *             const hasGroups = dataState.group && dataState.group.length;\n *\n *             const base_url = 'api/Products';\n *             const init = { method: 'GET', accept: 'application/json', headers: {} };\n *\n *             fetch(`${base_url}?${queryStr}`, init)\n *                 .then(response => response.json())\n *                 .then(({ data, total }) => {\n *                     this.setState({\n *                         data: hasGroups ? translateDataSourceResultGroups(data) : data,\n *                         total,\n *                         dataState\n *                     });\n *                 });\n *         }\n *     }\n * }\n * ```\n * {% endplatform_content %}\n */\nexport var toDataSourceRequestString = function (state) { return (toQueryString(Object.keys(state)\n    .map(rules(state))\n    .filter(isPresent)).join('&')); };\n/**\n * Converts a [DataSourceRequestState]({% slug api_kendo-data-query_datasourcerequeststate %}) into an object\n * that is compatible with the `DataSourceRequest` format in UI for ASP.NET MVC.\n *\n * @param {DataRequestState} state - The state that will be serialized.\n * @returns {any} - The serialized state.\n */\nexport var toDataSourceRequest = function (state) { return (toObject(Object.keys(state)\n    .map(rules(state, false))\n    .filter(isPresent))); };\n","import { isPresent } from '../utils';\nimport { compose } from '../funcs';\n// tslint:enable:max-line-length\nvar set = function (field, target, value) {\n    target[field] = value;\n    return target;\n};\nvar toCamelCase = function (str) { return str.replace(/(^[A-Z])/g, function (_, g1) { return g1.toLowerCase(); }); };\nvar prop = function (fieldName) { return function (obj) {\n    var value = obj[fieldName];\n    if (isPresent(value)) {\n        return value;\n    }\n    return obj[toCamelCase(fieldName)];\n}; };\nvar member = prop(\"Member\");\nvar aggregateMethodName = prop(\"AggregateMethodName\");\nvar value = prop(\"Value\");\nvar convert = function (mapper) { return function (values) { return Object.keys(values).reduce(mapper.bind(null, values), {}); }; };\nvar translateAggregate = convert(function (source, acc, field) { return set(field.toLowerCase(), acc, source[field]); });\nvar translateAggregates = convert(function (source, acc, field) { return set(field, acc, translateAggregate(source[field])); });\nvar valueOrDefault = function (value, defaultValue) { return isPresent(value) ? value : defaultValue; };\nvar normalizeGroup = function (group) { return ({\n    aggregates: group.Aggregates || group.aggregates,\n    field: group.Member || group.member || group.field,\n    hasSubgroups: group.HasSubgroups || group.hasSubgroups || false,\n    items: group.Items || group.items,\n    value: valueOrDefault(group.Key, valueOrDefault(group.key, group.value))\n}); };\nvar translateGroup = compose(function (_a) {\n    var field = _a.field, hasSubgroups = _a.hasSubgroups, value = _a.value, aggregates = _a.aggregates, items = _a.items;\n    return ({\n        aggregates: translateAggregates(aggregates),\n        field: field,\n        items: hasSubgroups ? items.map(translateGroup) : items,\n        value: value\n    });\n}, normalizeGroup);\n// tslint:disable:max-line-length\n/**\n * Converts the grouped result, which is returned into the `Data` field of the UI for ASP.NET MVC `ToDataSourceResult` method, to a comparable format.\n * @param data - The value of the `Data` field of the response.\n * @returns {GroupResult[]} - The converted result.\n */\nexport var translateDataSourceResultGroups = function (data) { return data.map(translateGroup); };\n/**\n * Converts the `AggregateResults` field content, which is returned by the UI for ASP.NET MVC `ToDataSourceResult` method, to a comparable format.\n * @param data - The value of the `AggregateResults` field of the response.\n * @returns {AggregateResult} - The converted result.\n */\n// tslint:enable:max-line-length\nexport var translateAggregateResults = function (data) { return ((data || []).reduce(function (acc, x) { return set(member(x), acc, set(aggregateMethodName(x).toLowerCase(), acc[member(x)] || {}, value(x))); }, {})); };\n","import { isPresent, isBlank } from '../utils';\nimport { getter } from '../accessor';\nvar compare = function (a, b) {\n    if (isBlank(a)) {\n        return a === b ? 0 : -1;\n    }\n    if (isBlank(b)) {\n        return 1;\n    }\n    if (a.localeCompare) {\n        return a.localeCompare(b);\n    }\n    return a > b ? 1 : (a < b ? -1 : 0);\n};\nvar compareDesc = function (a, b) { return compare(b, a); };\nvar descriptorAsFunc = function (descriptor) {\n    var prop = getter(descriptor.field, true);\n    return function (a, b) { return (descriptor.dir === 'asc' ? compare : compareDesc)(prop(a), prop(b)); };\n};\nvar initial = function (_a, _b) { return 0; };\n// tslint:disable:max-line-length\n/**\n * Converts the `SortDescriptors` into a [Comparer]({% slug api_kendo-data-query_comparer %}) function that can be used through `Array.sort`. If multiple descriptors are provided, sorting is applied in a right-to-left order.\n * @param {SortDescriptor[]} descriptors - The descriptors which will be converted.\n * @returns {Comparer} - The produced function.\n *\n * @example\n * ```ts\n * import { composeSortDescriptors } from '@progress/kendo-data-query';\n *\n * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n * const comparer = composeSortDescriptors([{ field: \"name\", dir: \"asc\" }]);\n * const result = data.sort(comparer);\n * // output: [{ name: \"Beef\" }, { name: \"Pepper\" }, { name: \"Pork\" }];\n * ```\n */\n// tslint:enable:max-line-length\nexport var composeSortDescriptors = function (descriptors) { return (descriptors\n    .filter(function (x) { return isPresent(x.dir); })\n    .map(function (descriptor) { return descriptorAsFunc(descriptor); })\n    .reduce(function (acc, curr) { return function (a, b) { return acc(a, b) || curr(a, b); }; }, initial)); };\n","import { isPresent, isNumeric, isDate } from './utils';\nimport { getter } from './accessor';\nvar valueToString = function (value) {\n    value = isPresent(value) && value.getTime ? value.getTime() : value;\n    return value + \"\";\n};\n/**\n * @hidden\n */\nexport var groupCombinator = function (field) {\n    var prop = getter(field, true);\n    var position = 0;\n    return function (agg, value) {\n        agg[field] = agg[field] || {};\n        var groupValue = prop(value);\n        var key = valueToString(groupValue);\n        var values = agg[field][key] || { __position: position++, aggregates: {}, items: [], value: groupValue };\n        values.items.push(value);\n        agg[field][key] = values;\n        return agg;\n    };\n};\n/**\n * @hidden\n */\nexport var expandAggregates = function (result) {\n    if (result === void 0) { result = {}; }\n    Object.keys(result).forEach(function (field) {\n        var aggregates = result[field];\n        Object.keys(aggregates).forEach(function (aggregate) {\n            aggregates[aggregate] = aggregates[aggregate].result();\n        });\n    });\n    return result;\n};\nvar aggregatesFuncs = function (name) { return ({\n    average: function () {\n        var value = 0;\n        var count = 0;\n        return {\n            calc: function (curr) {\n                if (isNumeric(curr)) {\n                    value += curr;\n                    count++;\n                }\n                else {\n                    value = curr;\n                }\n            },\n            result: function () { return isNumeric(value) ? value / count : value; }\n        };\n    },\n    count: function () {\n        var state = 0;\n        return {\n            calc: function () { return state++; },\n            result: function () { return state; }\n        };\n    },\n    max: function () {\n        var state = Number.NEGATIVE_INFINITY;\n        return {\n            calc: function (value) {\n                state = isNumeric(state) || isDate(state) ? state : value;\n                if (state < value && (isNumeric(value) || isDate(value))) {\n                    state = value;\n                }\n            },\n            result: function () { return state; }\n        };\n    },\n    min: function () {\n        var state = Number.POSITIVE_INFINITY;\n        return {\n            calc: function (value) {\n                state = isNumeric(state) || isDate(state) ? state : value;\n                if (state > value && (isNumeric(value) || isDate(value))) {\n                    state = value;\n                }\n            },\n            result: function () { return state; }\n        };\n    },\n    sum: function () {\n        var state = 0;\n        return {\n            calc: function (value) {\n                value = isPresent(value) ? value : 0;\n                state += value;\n            },\n            result: function () { return state; }\n        };\n    }\n}[name]()); };\n/**\n * @hidden\n */\nexport var aggregatesCombinator = function (descriptors) {\n    var functions = descriptors.map(function (descriptor) {\n        var fieldAccessor = getter(descriptor.field, true);\n        var aggregateName = (descriptor.aggregate || \"\").toLowerCase();\n        var aggregateAccessor = getter(aggregateName, true);\n        return function (state, value) {\n            var fieldAggregates = state[descriptor.field] || {};\n            var aggregateFunction = aggregateAccessor(fieldAggregates)\n                || aggregatesFuncs(aggregateName);\n            aggregateFunction.calc(fieldAccessor(value));\n            fieldAggregates[descriptor.aggregate] = aggregateFunction;\n            state[descriptor.field] = fieldAggregates;\n            return state;\n        };\n    });\n    return function (state, value) { return functions.reduce(function (agg, calc) { return calc(agg, value); }, state); };\n};\n/**\n * @hidden\n * Adds the value to the `arr` and produces a new array.\n *\n * > The original array will be modified.\n */\nexport var concat = function (arr, value) {\n    arr.push(value);\n    return arr;\n};\n/**\n * @hidden\n * Returns a reducer that will apply the specified transformation to the value.\n */\nexport var map = function (transform) { return (function (reduce) { return (function (acc, curr, index) { return reduce(acc, transform(curr, index)); }); }); };\n/**\n * @hidden\n * Returns a reducer that will filter out items which do not match the `Predicate`.\n */\nexport var filter = function (predicate) { return (function (reduce) { return (function (acc, curr) { return predicate(curr) ? reduce(acc, curr) : acc; }); }); };\n/**\n * @hidden\n */\nexport var isTransformerResult = function (source) {\n    return isPresent(source.__value);\n};\nvar reduced = function (x) {\n    if (isTransformerResult(x)) {\n        return x;\n    }\n    return {\n        __value: x,\n        reduced: true\n    };\n};\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport var take = function (count) { return (function (reduce) { return (function (acc, curr) { return count-- > 0 ? reduce(acc, curr) : reduced(acc); }); }); };\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport var takeWhile = function (predicate) { return (function (reduce) { return (function (acc, curr) { return predicate(curr) ? reduce(acc, curr) : reduced(acc); }); }); };\n/**\n * @hidden\n * Returns a reducer that will skip the specified number of items.\n */\nexport var skip = function (count) { return (function (reduce) { return (function (acc, curr) { return count-- <= 0 ? reduce(acc, curr) : acc; }); }); };\n/**\n * @hidden\n * Transforms the data by applying the supplied transformer.\n */\nexport var exec = function (transform, initialValue, data) {\n    var result = initialValue;\n    for (var idx = 0, length_1 = data.length; idx < length_1; idx++) {\n        result = transform(result, data[idx], idx);\n        if (isTransformerResult(result)) {\n            result = result.__value;\n            break;\n        }\n    }\n    return result;\n};\n","import { exec, map, aggregatesCombinator, expandAggregates } from '../transducers';\nvar identity = map(function (x) { return x; });\n// tslint:disable:max-line-length\n/**\n * Applies the specified [AggregateDescriptors]({% slug api_kendo-data-query_aggregatedescriptor %}) to the data. Returns an [AggregateResult]({% slug api_kendo-data-query_aggregateresult %}) instance.\n *\n * @example\n * ```ts\n * const data = [\n *    { unitPrice: 23, unitsInStock: 21 },\n *    { unitPrice: 10, unitsInStock: 12 },\n *    { unitPrice: 20, unitsInStock: 33 }\n * ];\n *\n * const result = aggregateBy(data, [\n *   { aggregate: \"sum\", field: \"unitPrice\" },\n *   { aggregate: \"sum\", field: \"unitsInStock\" }\n * ]);\n *\n * //output:\n * // {\n * //     \"unitPrice\": { \"sum\": 53 },\n * //     \"unitsInStock\": { \"sum\": 66 }\n * // }\n * ```\n * @param {T[]} data - The data on which the calculation will be executed.\n * @param {AggregateDescriptor[]} descriptors - The aggregate operations that will be executed.\n * @param {any} transformers - For internal use.\n * @returns {AggregateResult} - The aggregated result.\n * For more information, refer to the [aggregateresult]({% slug api_kendo-data-query_aggregateresult %}) configuration.\n */\n// tslint:enable:max-line-length\nexport var aggregateBy = function (data, descriptors, transformers) {\n    if (descriptors === void 0) { descriptors = []; }\n    if (transformers === void 0) { transformers = identity; }\n    var initialValue = {};\n    if (!descriptors.length) {\n        return initialValue;\n    }\n    var result = exec(transformers(aggregatesCombinator(descriptors)), initialValue, data);\n    return expandAggregates(result);\n};\n","import { isCompositeFilterDescriptor } from \"./filter-descriptor.interface\";\nimport { getter } from \"../accessor\";\nimport { isFunction, isPresent, isDate, isString, isBlank, isNumeric } from \"../utils\";\nvar logic = {\n    \"or\": {\n        concat: function (acc, fn) { return function (a) { return acc(a) || fn(a); }; },\n        identity: function () { return false; }\n    },\n    \"and\": {\n        concat: function (acc, fn) { return function (a) { return acc(a) && fn(a); }; },\n        identity: function () { return true; }\n    }\n};\nvar operatorsMap = {\n    contains: function (a, b) { return (a || \"\").indexOf(b) >= 0; },\n    doesnotcontain: function (a, b) { return (a || \"\").indexOf(b) === -1; },\n    doesnotendwith: function (a, b) { return (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) < 0; },\n    doesnotstartwith: function (a, b) { return (a || \"\").lastIndexOf(b, 0) === -1; },\n    endswith: function (a, b) { return (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) >= 0; },\n    eq: function (a, b) { return a === b; },\n    gt: function (a, b) { return a > b; },\n    gte: function (a, b) { return a >= b; },\n    isempty: function (a) { return a === ''; },\n    isnotempty: function (a) { return a !== ''; },\n    isnotnull: function (a) { return isPresent(a); },\n    isnull: function (a) { return isBlank(a); },\n    lt: function (a, b) { return a < b; },\n    lte: function (a, b) { return a <= b; },\n    neq: function (a, b) { return a != b; },\n    startswith: function (a, b) { return (a || \"\").lastIndexOf(b, 0) === 0; }\n};\nvar dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\nvar convertValue = function (value, ignoreCase) {\n    if (value != null && isString(value)) {\n        var date = dateRegExp.exec(value);\n        if (date) {\n            return new Date(+date[1]).getTime();\n        }\n        else if (ignoreCase) {\n            return value.toLowerCase();\n        }\n    }\n    else if (value != null && isDate(value)) {\n        return value.getTime();\n    }\n    return value;\n};\nvar typedGetter = function (prop, value, ignoreCase) {\n    if (!isPresent(value)) {\n        return prop;\n    }\n    var acc = prop;\n    if (isString(value)) {\n        var date = dateRegExp.exec(value);\n        if (date) {\n            value = new Date(+date[1]);\n        }\n        else {\n            acc = function (a) {\n                var x = prop(a);\n                if (typeof x === 'string' && ignoreCase) {\n                    return x.toLowerCase();\n                }\n                else {\n                    return isNumeric(x) ? x + \"\" : x;\n                }\n            };\n        }\n    }\n    if (isDate(value)) {\n        return function (a) {\n            var x = acc(a);\n            return isDate(x) ? x.getTime() : x;\n        };\n    }\n    return acc;\n};\nvar transformFilter = function (_a) {\n    var field = _a.field, ignoreCase = _a.ignoreCase, value = _a.value, operator = _a.operator;\n    field = !isPresent(field) ? function (a) { return a; } : field;\n    ignoreCase = isPresent(ignoreCase) ? ignoreCase : true;\n    var itemProp = typedGetter(isFunction(field) ? field : getter(field, true), value, ignoreCase);\n    value = convertValue(value, ignoreCase);\n    var op = isFunction(operator) ? operator : operatorsMap[operator];\n    return function (a) { return op(itemProp(a), value, ignoreCase); };\n};\n/**\n * @hidden\n */\nexport var transformCompositeFilter = function (filter) {\n    var combiner = logic[filter.logic];\n    return filter.filters\n        .filter(isPresent)\n        .map(function (x) { return isCompositeFilterDescriptor(x) ? transformCompositeFilter(x) : transformFilter(x); })\n        .reduce(combiner.concat, combiner.identity);\n};\n","import { isPresent } from '../utils';\nimport { isCompositeFilterDescriptor } from './filter-descriptor.interface';\nimport { normalizeFilters } from './filter.operators';\nimport { transformCompositeFilter } from \"./filter-no-eval\";\n// tslint:disable:max-line-length\n/**\n * Creates a [Predicate]({% slug api_kendo-data-query_predicate %}) function for the specified [CompositeFilterDescriptor]({% slug api_kendo-data-query_compositefilterdescriptor %}).\n *\n * @param {CompositeFilterDescriptor} descriptor - The descriptor for which the predicate is created.\n * @returns {Predicate} - The created function instance.\n *\n * @example\n * ```ts\n * import { compileFilter } from '@progress/kendo-data-query';\n *\n * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n * const predicate = compileFilter({ logic: \"and\", filters: [{ field: \"name\", operator: \"startswith\", value: \"P\" }] });\n * const result = data.filter(predicate);\n *\n * ```\n */\n// tslint:enable:max-line-length\nexport var compileFilter = function (descriptor) {\n    if (!descriptor || descriptor.filters.length === 0) {\n        return function () { return true; };\n    }\n    return transformCompositeFilter(descriptor);\n};\n// tslint:disable:max-line-length\n/**\n * Filters the provided array according to the specified [CompositeFilterDescriptor]({% slug api_kendo-data-query_compositefilterdescriptor %}).\n *\n * @param {T[]} data - The data that will be filtered.\n * @param {(CompositeFilterDescriptor | FilterDescriptor)} descriptor - The filter criteria that will be applied.\n * @returns {T[]} - The filtered data.\n *\n * @example\n * ```ts\n * import { filterBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *  { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *  { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *  { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = filterBy(data, {\n *     logic: 'and',\n *     filters: [\n *           { field: \"name\", operator: \"startswith\", value: \"p\", ignoreCase: true },\n *           { field: \"subcategory\", operator: \"eq\", value: \"Meat\" },\n *     ]\n * });\n *\n * // output:\n * // [{ \"name\": \"Pork\", \"category\": \"Food\", \"subcategory\": \"Meat\" }]\n * ```\n */\n// tslint:enable:max-line-length\nexport var filterBy = function (data, descriptor) {\n    if (!isPresent(descriptor) || (isCompositeFilterDescriptor(descriptor) && descriptor.filters.length === 0)) {\n        return data;\n    }\n    return data.filter(compileFilter(normalizeFilters(descriptor)));\n};\n","import { exec, map, groupCombinator } from '../transducers';\nimport { isArray, isPresent } from '../utils';\nimport { aggregateBy } from './aggregate.operators';\nimport { filterBy } from '../filtering/filter-expression.factory';\n/**\n * @hidden\n */\nexport var normalizeGroups = function (descriptors) {\n    descriptors = isArray(descriptors) ? descriptors : [descriptors];\n    return descriptors.map(function (x) { return Object.assign({ dir: \"asc\" }, x); });\n};\nvar identity = map(function (x) { return x; });\n/**\n * Groups the provided data according to the specified descriptors.\n *\n * @param {Array} data - The data that will be grouped.\n * @param {GroupDescriptor[]} descriptors - The descriptors.\n * @param {any} transformers - For internal use.\n * @param {Array} originalData - For internal use.\n * @returns {(Array<GroupResult<T>> | T[])} - The grouped data.\n *\n * @example\n * ```ts\n *\n * import { groupBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = groupBy(data, [{ field: \"subcategory\" }]);\n * ```\n */\nexport var groupBy = function (data, descriptors, transformers, originalData) {\n    if (descriptors === void 0) { descriptors = []; }\n    if (transformers === void 0) { transformers = identity; }\n    if (originalData === void 0) { originalData = data; }\n    descriptors = normalizeGroups(descriptors);\n    if (!descriptors.length) {\n        return data;\n    }\n    var descriptor = descriptors[0];\n    var initialValue = {};\n    var view = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);\n    var result = [];\n    Object.keys(view).forEach(function (field) {\n        Object.keys(view[field]).forEach(function (value) {\n            var group = view[field][value];\n            var aggregateResult = {};\n            var filteredData = originalData;\n            if (isPresent(descriptor.aggregates)) {\n                filteredData = filterBy(originalData, {\n                    field: descriptor.field,\n                    ignoreCase: false,\n                    operator: 'eq',\n                    value: group.value\n                });\n                aggregateResult = aggregateBy(filteredData, descriptor.aggregates);\n            }\n            result[group.__position] = {\n                aggregates: aggregateResult,\n                field: field,\n                items: descriptors.length > 1 ?\n                    groupBy(group.items, descriptors.slice(1), identity, filteredData)\n                    : group.items,\n                value: group.value\n            };\n        });\n    });\n    return result;\n};\n","var merge = function (data, left, middle, right, compare) {\n    var leftLength = middle - left;\n    var rightLength = right - middle;\n    var temp = [];\n    for (var idx = 0; idx < leftLength; idx++) {\n        temp.push(data[left + idx]);\n    }\n    var cursor1 = 0;\n    var cursor2 = middle;\n    var dest = left;\n    do {\n        if (compare(data[cursor2], temp[cursor1]) < 0) {\n            data[dest++] = data[cursor2++];\n            rightLength--;\n        }\n        else {\n            data[dest++] = temp[cursor1++];\n            leftLength--;\n        }\n    } while (rightLength > 0 && leftLength > 0);\n    while (leftLength) {\n        data[dest++] = temp[cursor1++];\n        leftLength--;\n    }\n    while (rightLength) {\n        data[dest++] = data[cursor2++];\n        rightLength--;\n    }\n};\n/**\n * @hidden\n */\nexport var sort = function (data, start, end, compare) {\n    if (end - start < 2) {\n        return;\n    }\n    var mid = (start + end) >>> 1; // tslint:disable-line:no-bitwise\n    sort(data, start, mid, compare);\n    sort(data, mid, end, compare);\n    merge(data, start, mid, end, compare);\n};\n","import { isPresent, isString } from './utils';\nimport { composeSortDescriptors } from './sorting/sort-array.operator';\nimport { groupBy, normalizeGroups } from './grouping/group.operators';\nimport { normalizeFilters } from './filtering/filter.operators';\nimport { compileFilter } from './filtering/filter-expression.factory';\nimport { exec, skip, take, filter, concat } from './transducers';\nimport { getter } from './accessor';\nimport { compose } from './funcs';\nimport { sort } from './sorting/sort';\n/**\n * Orders the specified array according to the provided sort descriptors.\n *\n * @param {T[]} data - The data to be sorted.\n * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.\n * @returns {T[]} - The sorted data.\n *\n * @example\n * ```ts\n * import { orderBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = orderBy(data, [{ field: \"name\", dir: \"asc\" }]);\n * ```\n */\nexport var orderBy = function (data, descriptors) {\n    if (descriptors.some(function (x) { return isPresent(x.dir); })) {\n        data = data.slice(0);\n        var comparer = composeSortDescriptors(descriptors);\n        sort(data, 0, data.length, comparer);\n    }\n    return data;\n};\nvar defaultComparer = function (a, b) { return a === b; };\nvar normalizeComparer = function (comparer) {\n    if (isString(comparer)) {\n        var accessor_1 = getter(comparer);\n        comparer = function (a, b) { return accessor_1(a) === accessor_1(b); };\n    }\n    return comparer;\n};\nvar _distinct = function (data, comparer) {\n    return data.filter(function (x, idx, xs) { return xs.findIndex(comparer.bind(null, x)) === idx; });\n};\n/**\n * Reduces the provided array so it contains only unique values.\n *\n * @param {T[]} data - The array that will be reduced.\n * @param {(Comparer | string)} comparer - An optional custom comparer function or the field name that will be used for comparison.\n * @returns {T[]} - The reduced data.\n *\n * @example\n * ```ts\n * import { distinct } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = distinct(data, \"subcategory\");\n *\n * // output:\n * // result => [\n * //     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n * //     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" }\n * // ];\n * ```\n */\nexport var distinct = function (data, comparer) {\n    if (comparer === void 0) { comparer = defaultComparer; }\n    return _distinct(data, normalizeComparer(comparer));\n};\n/**\n * @hidden\n */\nexport var count = function (data, predicate) {\n    var counter = 0;\n    for (var idx = 0, length_1 = data.length; idx < length_1; idx++) {\n        if (predicate(data[idx])) {\n            counter++;\n        }\n    }\n    return counter;\n};\n/**\n * @hidden\n */\nexport var limit = function (data, predicate) {\n    if (predicate) {\n        return data.filter(predicate);\n    }\n    return data;\n};\n/**\n * Applies the specified operation descriptors to the data.\n *\n * @param {T[]} data - The data to be processed.\n * @param {State} state - The operation descriptors that will be applied to the data.\n * @returns {DataResult} - The processed data.\n *\n * @example\n * ```ts\n *\n * const result = process(data, {\n *     skip: 10,\n *     take: 20,\n *     group: [{\n *       field: 'category.categoryName',\n *             aggregates: [\n *                   { aggregate: \"sum\", field: \"unitPrice\" },\n *                   { aggregate: \"sum\", field: \"unitsInStock\" }\n *             ]\n *       }],\n *     sort: [{ field: 'productName', dir: 'desc' }],\n *     filter: {\n *         logic: \"or\",\n *         filters: [\n *           { field: \"discontinued\", operator: \"eq\", value: true },\n *           { field: \"unitPrice\", operator: \"lt\", value: 22 }\n *         ]\n *     }\n * });\n *\n * ```\n */\nexport var process = function (data, state) {\n    var skipCount = state.skip, takeCount = state.take, filterDescriptor = state.filter, sort = state.sort, group = state.group;\n    var sortDescriptors = normalizeGroups(group || []).concat(sort || []);\n    if (sortDescriptors.length) {\n        data = orderBy(data, sortDescriptors);\n    }\n    var hasFilters = isPresent(filterDescriptor) && filter.length;\n    var hasGroups = isPresent(group) && group.length;\n    if (!hasFilters && !hasGroups) {\n        return {\n            data: takeCount ? data.slice(skipCount, skipCount + takeCount) : data,\n            total: data.length\n        };\n    }\n    var total;\n    var transformers = [];\n    var predicate;\n    if (hasFilters) {\n        predicate = compileFilter(normalizeFilters(filterDescriptor));\n        total = count(data, predicate);\n        transformers.push(filter(predicate));\n    }\n    else {\n        total = data.length;\n    }\n    if (isPresent(skipCount) && isPresent(takeCount)) {\n        transformers.push(skip(skipCount));\n        transformers.push(take(takeCount));\n    }\n    if (transformers.length) {\n        var transform = compose.apply(void 0, transformers);\n        var result = hasGroups ?\n            groupBy(data, group, transform, limit(data, predicate)) :\n            exec(transform(concat), [], data);\n        return { data: result, total: total };\n    }\n    return {\n        data: hasGroups ? groupBy(data, group) : data,\n        total: total\n    };\n};\n","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var setPrototypeOf = require(\"./setPrototypeOf.js\");\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inheritsLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"sourceRoot":""}